<!DOCTYPE html>
<html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Lorcana Logo Debug</title>
<style>
body { font-family: monospace; background: #1a1a2e; color: #e0e0e0; padding: 12px; margin: 0 auto; max-width: 900px; font-size: 13px; }
h1 { color: #4cc9f0; font-size: 18px; margin: 8px 0; }
.section { background: #16213e; border: 1px solid #333; padding: 12px; margin: 8px 0; border-radius: 8px; }
.ok { color: #4ade80; } .fail { color: #f87171; } .warn { color: #fbbf24; } .dim { color: #888; }
#log { white-space: pre-wrap; word-break: break-all; max-height: 60vh; overflow-y: auto; line-height: 1.4; }
button { background: #4cc9f0; color: #000; border: none; padding: 10px 16px; border-radius: 6px; cursor: pointer; font-size: 15px; margin: 4px; font-weight: bold; }
button:hover { background: #7dd3fc; }
.logo-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 8px; margin-top: 8px; }
.logo-cell { background: #0f0f23; border-radius: 6px; padding: 8px; text-align: center; }
.logo-cell img { max-width: 100%; max-height: 60px; display: block; margin: 0 auto 4px; }
.logo-cell .name { font-size: 11px; color: #aaa; }
.logo-cell .status { font-size: 11px; margin-top: 2px; }
</style></head>
<body>
<h1>Lorcana Logo Debug</h1>
<p style="color:#888; margin:4px 0;">Runs the same wiki API calls &amp; blob fetches the tracker uses. Works on mobile — no console needed.</p>

<div class="section">
<button onclick="runDiagnostic()">Run Full Diagnostic</button>
<button onclick="clearLog()">Clear</button>
<button onclick="copyLog()" id="copy-btn">Copy Log</button>
</div>

<div class="section" id="grid-section" style="display:none">
<b>Logo Results:</b>
<div class="logo-grid" id="logo-grid"></div>
</div>

<div class="section"><div id="log"></div></div>

<script>
var LOG = document.getElementById('log');
function log(msg, cls) {
    var span = document.createElement('span');
    span.className = cls || '';
    span.textContent = msg + '\n';
    LOG.appendChild(span);
    LOG.scrollTop = LOG.scrollHeight;
}
function clearLog() { LOG.innerHTML = ''; document.getElementById('grid-section').style.display = 'none'; }
function copyLog() {
    var text = LOG.innerText || LOG.textContent;
    if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(text).then(function() {
            var btn = document.getElementById('copy-btn');
            btn.textContent = 'Copied!';
            setTimeout(function() { btn.textContent = 'Copy Log'; }, 2000);
        }, function() { fallbackCopy(text); });
    } else {
        fallbackCopy(text);
    }
}
function fallbackCopy(text) {
    var ta = document.createElement('textarea');
    ta.value = text;
    ta.style.cssText = 'position:fixed;left:-9999px';
    document.body.appendChild(ta);
    ta.select();
    try { document.execCommand('copy'); var btn = document.getElementById('copy-btn'); btn.textContent = 'Copied!'; setTimeout(function() { btn.textContent = 'Copy Log'; }, 2000); }
    catch(e) { alert('Copy failed — please select log text manually'); }
    document.body.removeChild(ta);
}

var SET_NAMES = {
    'first-chapter':         'The_First_Chapter',
    'rise-of-the-floodborn': 'Rise_of_the_Floodborn',
    'into-the-inklands':     'Into_the_Inklands',
    'ursulas-return':        "Ursula's_Return",
    'shimmering-skies':      'Shimmering_Skies',
    'azurite-sea':           'Azurite_Sea',
    'archazias-island':      "Archazia's_Island",
    'reign-of-jafar':        'Reign_of_Jafar',
    'fabled':                'Fabled',
    'whispers-in-the-well':  'Whispers_in_the_Well',
    'winterspell':           'Winterspell'
};

function buildVariants(name) {
    var variants = [
        'File:' + name + '.png',
        'File:' + name + '_Logo.png',
        'File:' + name + '_logo.png',
        'File:' + name + '_Logo.jpg',
        'File:' + name + '_logo.jpg',
        'File:' + name + '_Image.webp',
        'File:' + name + '_Image.png',
        'File:' + name + '.webp',
        'File:' + name + '.jpeg',
        'File:' + name + '.jpg'
    ];
    if (name.indexOf("'") !== -1) {
        var clean = name.replace(/'/g, '');
        var unicode = name.replace(/'/g, '\u2019');
        variants.push(
            'File:' + clean + '.png', 'File:' + clean + '_Logo.png',
            'File:' + clean + '.webp', 'File:' + clean + '.jpeg', 'File:' + clean + '.jpg',
            'File:' + unicode + '.png', 'File:' + unicode + '_Logo.png',
            'File:' + unicode + '.webp', 'File:' + unicode + '.jpeg', 'File:' + unicode + '.jpg');
    }
    return variants;
}

// Hard skip: images that are never useful as set logos
var SKIP_PATTERN = /gift.set|booster|starter|deck|pack|sleeve|promo|box|trove|kit|bundle|blister|display|card|puzzle|concept.art|product.line|portfolio|contents|sealed|back\)|side.view|top|bottom|page.\d|in.stock|fanart|reprint|comparison|trailer|screenshot|collection|master.set|texture|organized.play/i;
// Soft penalty: might be acceptable as a last-resort fallback (banner, key art)
var SOFT_PENALTY_PATTERN = /banner|key.art/i;

// Score a filename match: lower = better
function scoreMatch(filename, setName) {
    var baseName = filename.replace(/\.\w+$/, '');
    var ext = (filename.match(/\.(\w+)$/) || ['', ''])[1].toLowerCase();
    var score;
    if (baseName.toLowerCase() === setName.toLowerCase()) score = 0;
    else if (/logo|image/i.test(baseName)) score = 10;
    else if (SOFT_PENALTY_PATTERN.test(filename)) score = 80;
    else score = 50 + baseName.length;
    // Prefer PNG (transparent) over JPEG/JPG when scores are equal
    var formatBonus = (ext === 'png') ? 0 : 0.5;
    return score + formatBonus;
}

// Match search result pages to missing sets with scoring
function matchSearchResults(pages, missingKeys, foundUrls, label) {
    var candidates = {}; // setKey → [{url, score, filename}]
    var pageList = Object.keys(pages).map(function(pid) { return pages[pid]; });
    log(label + ' returned ' + pageList.length + ' files');

    pageList.forEach(function(page) {
        if (!page.imageinfo || !page.imageinfo[0] || !page.imageinfo[0].url) return;
        var filename = (page.title || '').replace(/^File:/, '');

        if (SKIP_PATTERN.test(filename)) {
            log('  SKIP: ' + filename, 'dim');
            return;
        }

        missingKeys.forEach(function(k) {
            if (foundUrls[k]) return;
            var setName = SET_NAMES[k].replace(/_/g, ' ');
            if (filename.toLowerCase().indexOf(setName.toLowerCase()) === -1) return;

            var score = scoreMatch(filename, setName);
            log('  CANDIDATE: ' + k + ' → ' + filename + ' (score=' + score + ')', score < 1 ? 'ok' : 'warn');
            if (!candidates[k]) candidates[k] = [];
            candidates[k].push({ url: page.imageinfo[0].url, score: score, filename: filename });
        });
    });

    var matched = 0;
    Object.keys(candidates).forEach(function(k) {
        if (foundUrls[k]) return;
        candidates[k].sort(function(a, b) { return a.score - b.score; });
        var best = candidates[k][0];
        foundUrls[k] = best.url;
        matched++;
        log('  BEST: ' + k + ' → ' + best.filename + ' (score=' + best.score + ')', 'ok');
        log('    → ' + best.url.substring(0, 100) + '...', 'dim');
    });
    log(label + ' matched ' + matched + ' sets', matched > 0 ? 'ok' : 'warn');
}

// Phase 2: batch search for missing sets
async function searchWikiBatch(missingKeys, foundUrls) {
    if (missingKeys.length === 0) return;

    // Include apostrophe-stripped variants
    var terms = [];
    missingKeys.forEach(function(k) {
        var name = SET_NAMES[k].replace(/_/g, ' ');
        terms.push('"' + name + '"');
        if (name.indexOf("'") !== -1) terms.push('"' + name.replace(/'/g, '') + '"');
    });
    var searchQuery = terms.join(' OR ');

    log('\n--- Fandom (batch search) ---');
    log('Searching for: ' + missingKeys.join(', '));
    log('Query: ' + searchQuery, 'dim');

    var resp = await fetch('https://lorcana.fandom.com/api.php?action=query' +
        '&generator=search&gsrnamespace=6&gsrsearch=' + encodeURIComponent(searchQuery) +
        '&gsrlimit=50&prop=imageinfo&iiprop=url&format=json&origin=*',
        { referrerPolicy: 'no-referrer' });
    log('HTTP ' + resp.status, resp.ok ? 'ok' : 'fail');
    if (!resp.ok) throw new Error('HTTP ' + resp.status);

    var data = await resp.json();
    var pages = data && data.query && data.query.pages;
    if (!pages) { log('No results!', 'fail'); return; }
    matchSearchResults(pages, missingKeys, foundUrls, 'Batch search');
}

// Phase 3: individual searches for sets still missing after batch
async function searchWikiIndividual(missingKeys, foundUrls) {
    for (var i = 0; i < missingKeys.length; i++) {
        var k = missingKeys[i];
        if (foundUrls[k]) continue;

        var name = SET_NAMES[k].replace(/_/g, ' ');
        var searchNames = [name];
        if (name.indexOf("'") !== -1) searchNames.push(name.replace(/'/g, ''));

        for (var ni = 0; ni < searchNames.length; ni++) {
            if (foundUrls[k]) break;
            log('\n--- Fandom (individual: "' + searchNames[ni] + '") ---');

            try {
                var resp = await fetch('https://lorcana.fandom.com/api.php?action=query' +
                    '&generator=search&gsrnamespace=6&gsrsearch=' + encodeURIComponent('"' + searchNames[ni] + '"') +
                    '&gsrlimit=20&prop=imageinfo&iiprop=url&format=json&origin=*',
                    { referrerPolicy: 'no-referrer' });
                log('HTTP ' + resp.status, resp.ok ? 'ok' : 'fail');
                if (!resp.ok) continue;

                var data = await resp.json();
                var pages = data && data.query && data.query.pages;
                if (!pages) { log('No results', 'warn'); continue; }
                matchSearchResults(pages, [k], foundUrls, 'Individual search');
            } catch (e) {
                log('Error: ' + e.message, 'fail');
            }
        }
    }
}

async function testBlobFetch(url, label) {
    log('  Blob fetch: ' + url.substring(0, 80) + '...');
    try {
        var resp = await fetch(url, { referrerPolicy: 'no-referrer' });
        if (!resp.ok) {
            log('  HTTP ' + resp.status, 'fail');
            return null;
        }
        var blob = await resp.blob();
        log('  Blob: size=' + blob.size + ' type=' + blob.type, blob.size > 200 ? 'ok' : 'fail');
        if (blob.size < 200) {
            // Read tiny blobs as text to see what the CDN returned
            try {
                var text = await blob.text();
                log('  Tiny blob content: "' + text + '"', 'warn');
            } catch (e) { /* ignore */ }
            log('  Too small — rejected (threshold: 200 bytes)', 'fail');
            return null;
        }
        return URL.createObjectURL(blob);
    } catch (e) {
        log('  Blob error: ' + e.message, 'fail');
        return null;
    }
}

async function runDiagnostic() {
    clearLog();
    log('=== Lorcana Logo Diagnostic ===');
    log('Date: ' + new Date().toISOString());
    log('UA: ' + navigator.userAgent);
    log('Origin: ' + location.origin);

    var setKeys = Object.keys(SET_NAMES);
    log('\nSets: ' + setKeys.join(', '));

    var foundUrls = {};

    // Phase 1: Direct PNG filename guessing — transparent logo files like Fabled.png.
    // Prefer .png (transparent background) over .jpeg/.jpg for clean logos.
    log('\n--- Phase 1: Direct PNG Filename Guessing ---');
    log('Trying common logo filename patterns (PNG first for transparency)...');

    var allFiles = [];
    var fileToSet = {};
    setKeys.forEach(function(k) {
        var variants = buildVariants(SET_NAMES[k]);
        variants.forEach(function(f, i) {
            allFiles.push(f);
            var normalized = f.replace(/_/g, ' ');
            if (!fileToSet[normalized] || i < fileToSet[normalized].priority) {
                fileToSet[normalized] = { setKey: k, priority: i };
            }
        });
    });

    log('Querying ' + allFiles.length + ' filename variants (batched to 50)...');
    var phase1Best = {}; // setKey → { priority, url, title }
    try {
        for (var batchStart = 0; batchStart < allFiles.length; batchStart += 50) {
            var batch = allFiles.slice(batchStart, batchStart + 50);
            log('  Batch ' + (Math.floor(batchStart/50)+1) + ': ' + batch.length + ' titles', 'dim');
            var titleParam = batch.map(function(t) { return t.replace(/ /g, '_'); }).join('|');
            var resp = await fetch('https://lorcana.fandom.com/api.php?action=query&titles=' +
                encodeURIComponent(titleParam) + '&prop=imageinfo&iiprop=url&format=json&origin=*',
                { referrerPolicy: 'no-referrer' });
            log('  HTTP ' + resp.status, resp.ok ? 'ok' : 'fail');

            if (resp.ok) {
                var data = await resp.json();
                if (data.warnings) log('  API warnings: ' + JSON.stringify(data.warnings), 'warn');
                var pages = data && data.query && data.query.pages;
                if (pages) {
                    var pageIds = Object.keys(pages);
                    var withInfo = pageIds.filter(function(pid) { return pages[pid].imageinfo; }).length;
                    var missing = pageIds.filter(function(pid) { return parseInt(pid) < 0; }).length;
                    log('  Pages: ' + pageIds.length + ' total, ' + withInfo + ' with imageinfo, ' + missing + ' missing', 'dim');
                    Object.keys(pages).forEach(function(pid) {
                        var page = pages[pid];
                        if (!page.imageinfo || !page.imageinfo[0] || !page.imageinfo[0].url) return;
                        var entry = fileToSet[page.title];
                        if (!entry) {
                            log('  UNMATCHED page.title: "' + page.title + '" (has imageinfo but no fileToSet entry)', 'warn');
                            return;
                        }
                        var sk = entry.setKey;
                        if (!phase1Best[sk] || entry.priority < phase1Best[sk].priority) {
                            if (phase1Best[sk]) {
                                log('  ' + sk + ': upgrading from priority ' + phase1Best[sk].priority + ' → ' + entry.priority + ' (' + page.title + ')', 'ok');
                            }
                            phase1Best[sk] = { priority: entry.priority, url: page.imageinfo[0].url, title: page.title };
                        }
                    });
                }
            }
        }
    } catch (e) {
        log('Filename guessing ERROR: ' + e.message, 'fail');
    }
    // Commit best matches
    Object.keys(phase1Best).forEach(function(sk) {
        foundUrls[sk] = phase1Best[sk].url;
        log('  ' + sk + ': found via ' + phase1Best[sk].title + ' (priority=' + phase1Best[sk].priority + ')', 'ok');
        log('    → ' + phase1Best[sk].url.substring(0, 100) + '...', 'dim');
    });

    var phase1Found = Object.keys(foundUrls).length;
    log('\nFilename guessing found ' + phase1Found + '/' + setKeys.length + ' sets', phase1Found === setKeys.length ? 'ok' : 'warn');

    // Phase 2: Article page parsing — find infobox images via prop=images.
    var missingKeys = setKeys.filter(function(k) { return !foundUrls[k]; });
    if (missingKeys.length > 0) {
        log('\n--- Phase 2: Article Page Parsing ---');
        log(missingKeys.length + ' sets still missing: ' + missingKeys.join(', '), 'warn');
        log('Fetching article pages to find infobox images...');

        var articleTitles = missingKeys.map(function(k) { return SET_NAMES[k]; }).join('|');
        var titleToKey = {};
        missingKeys.forEach(function(k) {
            titleToKey[SET_NAMES[k].replace(/_/g, ' ')] = k;
        });

        var articleSkipPattern = /booster|starter|deck|pack|sleeve|promo|box|trove|kit|bundle|blister|display|gift.set|master.set|contents|sealed|costco|collector/i;

        try {
            var articleImages = {}; // setKey → [filenames]
            var imcontinue = '';
            for (var attempt = 0; attempt < 3; attempt++) {
                var apiUrl2 = 'https://lorcana.fandom.com/api.php?action=query&titles=' +
                    encodeURIComponent(articleTitles) + '&prop=images&imlimit=50&format=json&origin=*';
                if (imcontinue) apiUrl2 += '&imcontinue=' + encodeURIComponent(imcontinue);

                var resp2 = await fetch(apiUrl2, { referrerPolicy: 'no-referrer' });
                log('HTTP ' + resp2.status, resp2.ok ? 'ok' : 'fail');
                if (!resp2.ok) break;

                var data2 = await resp2.json();
                var pages2 = data2 && data2.query && data2.query.pages;
                if (pages2) {
                    Object.keys(pages2).forEach(function(pid) {
                        var page = pages2[pid];
                        var sk = titleToKey[page.title];
                        if (!sk) { log('  Unknown page: ' + page.title, 'warn'); return; }
                        if (!page.images || page.images.length === 0) return;
                        if (!articleImages[sk]) articleImages[sk] = [];
                        page.images.forEach(function(im) {
                            articleImages[sk].push(im.title);
                        });
                    });
                }
                if (!data2['continue'] || !data2['continue'].imcontinue) break;
                imcontinue = data2['continue'].imcontinue;
            }

            // Pick best image for each set: prefer name-matching, skip product images
            var imageFiles = [];
            Object.keys(articleImages).forEach(function(sk) {
                var imgs = articleImages[sk];
                var setName = SET_NAMES[sk].replace(/_/g, ' ').toLowerCase();
                log('  ' + sk + ' article images (' + imgs.length + '): ' + imgs.map(function(t) { return t.replace('File:', ''); }).join(', '), 'dim');

                var best = null;
                var bestScore = 999;
                imgs.forEach(function(title) {
                    var fname = title.replace(/^File:/, '').toLowerCase();
                    if (articleSkipPattern.test(fname)) return;
                    var score = 50;
                    var baseName = fname.replace(/\.\w+$/, '').replace(/_/g, ' ');
                    if (baseName === setName) score = 0;
                    else if (fname.indexOf(setName) !== -1) score = 10;
                    if (score < bestScore) {
                        bestScore = score;
                        best = title;
                    }
                });
                if (best) {
                    log('  ' + sk + ' → best match: ' + best + ' (score=' + bestScore + ')', 'ok');
                    imageFiles.push({ setKey: sk, filename: best });
                } else {
                    log('  ' + sk + ': no suitable image found on article page', 'fail');
                }
            });

            // Report sets with no article images at all
            missingKeys.forEach(function(k) {
                if (!articleImages[k]) {
                    log('  ' + k + ': no images on article page', 'fail');
                }
            });

            if (imageFiles.length > 0) {
                log('\nResolving ' + imageFiles.length + ' image filenames to CDN URLs...');
                var fileTitles = imageFiles.map(function(f) { return f.filename; }).join('|');
                var resp3 = await fetch('https://lorcana.fandom.com/api.php?action=query&titles=' +
                    encodeURIComponent(fileTitles) + '&prop=imageinfo&iiprop=url&format=json&origin=*',
                    { referrerPolicy: 'no-referrer' });
                log('HTTP ' + resp3.status, resp3.ok ? 'ok' : 'fail');

                if (resp3.ok) {
                    var data3 = await resp3.json();
                    var filePages = data3 && data3.query && data3.query.pages;
                    var fileUrlMap = {};
                    if (filePages) {
                        Object.keys(filePages).forEach(function(pid) {
                            var fp = filePages[pid];
                            if (fp.imageinfo && fp.imageinfo[0] && fp.imageinfo[0].url) {
                                fileUrlMap[fp.title] = fp.imageinfo[0].url;
                            }
                        });
                    }
                    imageFiles.forEach(function(f) {
                        var url = fileUrlMap[f.filename] || fileUrlMap[f.filename.replace(/_/g, ' ')];
                        if (url) {
                            foundUrls[f.setKey] = url;
                            log('  ' + f.setKey + ': resolved', 'ok');
                            log('    → ' + url.substring(0, 100) + '...', 'dim');
                        } else {
                            log('  ' + f.setKey + ': could not resolve ' + f.filename, 'fail');
                        }
                    });
                }
            }
        } catch (e) {
            log('Article parsing ERROR: ' + e.message, 'fail');
        }

        var phase2Found = Object.keys(foundUrls).length;
        log('\nAfter article parsing: ' + phase2Found + '/' + setKeys.length + ' sets', phase2Found === setKeys.length ? 'ok' : 'warn');
    }

    // Phase 3: Search fallback for any sets still missing
    var stillMissing = setKeys.filter(function(k) { return !foundUrls[k]; });
    if (stillMissing.length > 0) {
        log('\n--- Phase 3: Search Fallback ---');
        log(stillMissing.length + ' sets still missing: ' + stillMissing.join(', '), 'warn');
        try {
            await searchWikiIndividual(stillMissing, foundUrls);
        } catch (e) {
            log('Search ERROR: ' + e.message, 'fail');
        }
    }

    // Summary
    log('\n=== SUMMARY ===');
    var foundCount = 0;
    setKeys.forEach(function(k) {
        if (foundUrls[k]) {
            foundCount++;
            log(k + ': URL found', 'ok');
        } else {
            log(k + ': NO URL', 'fail');
        }
    });
    log(foundCount + '/' + setKeys.length + ' sets have CDN URLs', foundCount === setKeys.length ? 'ok' : 'warn');

    // Blob fetch test
    log('\n=== BLOB FETCH TEST ===');
    log('Testing if CDN URLs actually return image data...');

    var grid = document.getElementById('logo-grid');
    var gridSection = document.getElementById('grid-section');
    grid.innerHTML = '';
    gridSection.style.display = 'block';

    for (var i = 0; i < setKeys.length; i++) {
        var sk = setKeys[i];
        var cell = document.createElement('div');
        cell.className = 'logo-cell';

        var nameEl = document.createElement('div');
        nameEl.className = 'name';
        nameEl.textContent = sk;

        var statusEl = document.createElement('div');
        statusEl.className = 'status';

        var imgEl = document.createElement('img');

        if (!foundUrls[sk]) {
            statusEl.textContent = 'No URL';
            statusEl.className = 'status fail';
            imgEl.style.display = 'none';
        } else {
            log('\n' + sk + ':');
            var blobUrl = await testBlobFetch(foundUrls[sk], sk);
            if (blobUrl) {
                imgEl.src = blobUrl;
                statusEl.textContent = 'OK';
                statusEl.className = 'status ok';
            } else {
                statusEl.textContent = 'Blob failed';
                statusEl.className = 'status fail';
                imgEl.style.display = 'none';
            }
        }

        cell.appendChild(imgEl);
        cell.appendChild(nameEl);
        cell.appendChild(statusEl);
        grid.appendChild(cell);
    }

    log('\n=== DONE ===', 'ok');
}
</script>
</body></html>
